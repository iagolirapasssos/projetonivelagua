dist/bundle.js:
(()=>{var e={apiKey:process.env.API_KEY_PLACEHOLDER,authDomain:process.env.AUTH_DOMAIN_PLACEHOLDER,databaseURL:process.env.DATABASE_URL_PLACEHOLDER,projectId:process.env.PROJECT_ID_PLACEHOLDER,storageBucket:process.env.STORAGE_BUCKET_PLACEHOLDER,messagingSenderId:process.env.MESSAGING_SENDER_ID_PLACEHOLDER,appId:process.env.APP_ID_PLACEHOLDER,measurementId:process.env.MEASUREMENT_ID_PLACEHOLDER},a=firebase.initializeApp(e),t=firebase.database(a),n=null,o=null;function r(e){var a=firebase.database().ref(t,"sensors/".concat(e));firebase.database().onValue(a,(function(a){var t=[],o=[];a.forEach((function(e){var a=e.val();t.push(a.altura),o.push(a.tempo)}));var r=document.getElementById("myChart").getContext("2d");n&&"function"==typeof n.destroy&&n.destroy(),n=new Chart(r,{type:"line",data:{labels:o,datasets:[{label:"Dados de ".concat(e),data:t,backgroundColor:"rgba(255, 99, 132, 0.2)",borderColor:"rgba(255, 99, 132, 1)",borderWidth:1}]},options:{scales:{y:{beginAtZero:!0}}}})}))}document.getElementById("sensorSelect").addEventListener("change",(function(e){r(e.target.value)}));var s=firebase.database().ref(t,"sensors");firebase.database().onValue(s,(function(e){var a=document.getElementById("sensorSelect");a.innerHTML="";var n,s=null;e.forEach((function(e){var t=e.key;s||(s=t);var n=document.createElement("option");n.value=t,n.textContent=t,a.appendChild(n)})),s&&(a.value=s,r(s),n=firebase.database().ref(t,"sensors"),firebase.database().onValue(n,(function(e){var a=[];e.forEach((function(e){var t=[],n=[];e.forEach((function(e){var a=e.val();t.push(a.altura),n.push(a.tempo)})),a.push({label:"Dados de ".concat(e.key),data:t.map((function(e,a){return{x:n[a],y:e}})),borderColor:"rgba(".concat(Math.floor(255*Math.random()),", ").concat(Math.floor(255*Math.random()),", ").concat(Math.floor(255*Math.random()),", 1)"),borderWidth:1,fill:!1,tension:.1})}));var t=document.getElementById("allSensorsChart").getContext("2d");o&&"function"==typeof o.destroy&&o.destroy(),o=new Chart(t,{type:"line",data:{datasets:a},options:{scales:{x:{type:"linear",position:"bottom"},y:{beginAtZero:!0}}}})})))}))})();

index.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gráfico de Altura x Tempo</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database.js"></script>
</head>
<body>
    <div>
        <label for="sensorSelect">Escolha um sensor:</label>
        <select id="sensorSelect"></select>
    </div>
    <div>
        <canvas id="myChart"></canvas>
    </div>
    <div>
        <canvas id="allSensorsChart"></canvas>
    </div>
    <script src="/dist/bundle.js"></script>
</body>
</html>


package.json:
{
  "name": "ProjetoMedirNivel",
  "version": "1.0.0",
  "description": "",
  "main": "script.js",
  "scripts": {
    "build": "webpack --mode production"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.24.5",
    "@babel/preset-env": "^7.24.5",
    "babel-loader": "^9.1.3",
    "webpack": "^5.91.0",
    "webpack-cli": "^5.1.4"
  }
}


src/script.js:
// Configuração do Firebase já estará carregada via HTML
const firebaseConfig = {
  apiKey: process.env.API_KEY_PLACEHOLDER,
  authDomain: process.env.AUTH_DOMAIN_PLACEHOLDER,
  databaseURL: process.env.DATABASE_URL_PLACEHOLDER,
  projectId: process.env.PROJECT_ID_PLACEHOLDER,
  storageBucket: process.env.STORAGE_BUCKET_PLACEHOLDER,
  messagingSenderId: process.env.MESSAGING_SENDER_ID_PLACEHOLDER,
  appId: process.env.APP_ID_PLACEHOLDER,
  measurementId: process.env.MEASUREMENT_ID_PLACEHOLDER
};

const app = firebase.initializeApp(firebaseConfig);
const database = firebase.database(app);

let myChart = null;
let allSensorsChart = null;

function loadAllSensorsData() {
    const allSensorsRef = firebase.database().ref(database, 'sensors');

    firebase.database().onValue(allSensorsRef, (snapshot) => {
        const allDatasets = [];
        snapshot.forEach((sensorSnapshot) => {
            const dadosAltura = [];
            const dadosTempo = [];

            sensorSnapshot.forEach((dataSnapshot) => {
                const data = dataSnapshot.val();
                dadosAltura.push(data.altura);
                dadosTempo.push(data.tempo);
            });

            allDatasets.push({
                label: `Dados de ${sensorSnapshot.key}`,
                data: dadosAltura.map((height, index) => ({ x: dadosTempo[index], y: height })),
                borderColor: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 1)`,
                borderWidth: 1,
                fill: false,
                tension: 0.1
            });
        });

        const ctxAll = document.getElementById('allSensorsChart').getContext('2d');
        if (allSensorsChart && typeof allSensorsChart.destroy === 'function') {
            allSensorsChart.destroy();
        }
        allSensorsChart = new Chart(ctxAll, {
            type: 'line',
            data: {
                datasets: allDatasets
            },
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom'
                    },
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });
    });
}

function loadSensorData(sensorId) {
    const sensorRef = firebase.database().ref(database, `sensors/${sensorId}`);

    firebase.database().onValue(sensorRef, (snapshot) => {
        const dadosAltura = [];
        const dadosTempo = [];

        snapshot.forEach((childSnapshot) => {
            const data = childSnapshot.val();
            dadosAltura.push(data.altura);
            dadosTempo.push(data.tempo);
        });

        const ctx = document.getElementById('myChart').getContext('2d');
        if (myChart && typeof myChart.destroy === 'function') {
            myChart.destroy();
        }
        myChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: dadosTempo,
                datasets: [{
                    label: `Dados de ${sensorId}`,
                    data: dadosAltura,
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });
    });
}

document.getElementById('sensorSelect').addEventListener('change', (e) => {
    loadSensorData(e.target.value);
});

const sensorsRef = firebase.database().ref(database, 'sensors');
firebase.database().onValue(sensorsRef, (snapshot) => {
    const select = document.getElementById('sensorSelect');
    select.innerHTML = '';
    let firstSensor = null;
    snapshot.forEach((childSnapshot) => {
        const sensorKey = childSnapshot.key;
        if (!firstSensor) firstSensor = sensorKey;
        const option = document.createElement('option');
        option.value = sensorKey;
        option.textContent = sensorKey;
        select.appendChild(option);
    });

    if (firstSensor) {
        select.value = firstSensor;
        loadSensorData(firstSensor);
        loadAllSensorsData(); // Load all sensors data for the general chart
    }
});


webpack.config.js:
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: '/src/script.js',  // Certifique-se de que esse é o caminho correto para seu arquivo de entrada principal
  output: {
    path: path.resolve(__dirname, 'dist'),  // Este é o diretório onde os arquivos resultantes serão colocados
    filename: 'bundle.js'  // O nome do arquivo de saída
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      }
    ]
  },
  plugins: [
    new webpack.DefinePlugin({
      'process.env.API_KEY': JSON.stringify(process.env.API_KEY),
      'process.env.AUTH_DOMAIN': JSON.stringify(process.env.AUTH_DOMAIN),
      'process.env.DATABASE_URL': JSON.stringify(process.env.DATABASE_URL),
      'process.env.PROJECT_ID': JSON.stringify(process.env.PROJECT_ID),
      'process.env.STORAGE_BUCKET': JSON.stringify(process.env.STORAGE_BUCKET),
      'process.env.MESSAGING_SENDER_ID': JSON.stringify(process.env.MESSAGING_SENDER_ID),
      'process.env.APP_ID': JSON.stringify(process.env.APP_ID),
      'process.env.MEASUREMENT_ID': JSON.stringify(process.env.MEASUREMENT_ID)
    })
  ],
  mode: 'production'
};

